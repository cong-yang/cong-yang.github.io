<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">


<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Publications | Programming Group</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Publications" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Publications in reversed chronological order." />
<meta property="og:description" content="Publications in reversed chronological order." />
<link rel="canonical" href="https://programming-group.com/publications" />
<meta property="og:url" content="https://programming-group.com/publications" />
<meta property="og:site_name" content="Programming Group" />
<meta property="og:image" content="https://programming-group.com/assets/img/og/pg.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://programming-group.com/assets/img/og/pg.png" />
<meta property="twitter:title" content="Publications" />
<meta name="google-site-verification" content="RMUCoHAseeFv2jAdfyJb4XLx4e1J8XpU1l8fvwAxk1g" />
<script type="application/ld+json">
{"@type":"WebPage","description":"Publications in reversed chronological order.","image":"https://programming-group.com/assets/img/og/pg.png","headline":"Publications","url":"https://programming-group.com/publications","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<!-- Styles -->
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/assets/css/bundle-1e30bbe54ea0bcfc79fd9ff0bac804df.css">
<link rel="stylesheet" href="/assets/css/main.css?v=d8c386a381b1ccca190efa5b4292c1032fb2f9bd" />

  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header class="fixed-top">

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand">
    <div class="container px-md-3">
      <a href="/" class="">
        <img src="/assets/img/pg-logo.svg" alt="Programming Group"/>
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-wrap">
          <!-- About -->
          
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/">
                Home
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/team">
                Team
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/teaching">
                Teaching
                
              </a>
          </li>
          
          
          
          <li class="nav-item active">
              <a class="nav-link text-nowrap" href="/publications">
                Publications
                
                <span class="sr-only">(current)</span>
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/open-positions">
                Open Positions
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/contact">
                Contact
                
              </a>
          </li>
          
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      <div class="post">

  <header class="post-header">
    <span class="social-header float-right">
  <a href="mailto:%67%75%69%64%6F.%73%61%6C%76%61%6E%65%73%63%68%69@%75%6E%69%73%67.%63%68"><i class="fas fa-envelope"></i></a>
  
  
  
  
  
  
  <a href="https://twitter.com/prg_grp" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a>
  <a href="https://www.youtube.com/channel/UCW60aqeksbbWTT-7sR6G97w" target="_blank" title="YouTube"><i class="fab fa-youtube"></i></a>
  
  
  
  
  
  
  
</span>

    <h1 class="post-title">Publications</h1>
    
  </header>

  <article>
    <div class="publications">


  <h2 class="year">2023</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Sokolowski:2023:Decentralizing" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">IEEE Software</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/mjuz">µs <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Decentralizing Infrastructure as Code</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>IEEE Software</em> 40 (01), 2023
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2023_Decentralizing-Infrastructure-as-Code.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/MS.2022.3192968" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Infrastructure as Code (IaC) automates deployments for single teams, falling short of decentralized deployments across groups. We need mature IaC solutions that embrace and consolidate software engineering principles to enable testing and automation advances for decentralized organizations.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2022</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Sokolowski:2022:Infrastructure" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ESEC/FSE DS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/mjuz">µs <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Infrastructure as Code for Dynamic Deployments</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, ESEC/FSE, 2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2022_Infrastructure-as-Code-for-Dynamic-Deployments.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3540250.3558912" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Modern DevOps organizations require a high degree of automation to achieve software stability at frequent changes. Further, there is a need for flexible, timely reconfiguration of the infrastructure, e.g., to use pay-per-use infrastructure efficiently based on application load. Infrastructure as Code (IaC) is the DevOps tool to automate infrastructure. However, modern static IaC solutions only support infrastructures that are deployed and do not change afterward. To implement infrastructures that change dynamically over time, static IaC programs have to be (updated and) re-run, e.g., in a CI/CD pipeline, or configure an external orchestrator that implements the dynamic behavior, e.g., an autoscaler or Kubernetes operator. Both do not capture the dynamic behavior in the IaC program and prevent analyzing and testing the infrastructure configuration jointly with its dynamic behavior.</p><p>To fill this gap, we envision dynamic IaC, which augments static IaC with the ability to define dynamic behavior within the IaC program. In contrast to static IaC programs, dynamic IaC programs run continuously. They re-evaluate program parts that depend on external signals when these change and automatically adjust the infrastructure accordingly. We implement DIaC as the first dynamic IaC solution and demonstrate it in two realistic use cases of broader relevance. With dynamic IaC, ensuring the program’s correctness is even harder than for static IaC because programs may define many target configurations in contrast to only a few. However, for this reason, it is also more critical. To solve this issue, we propose automated, specialized property-based testing for IaC programs and implement it in ProTI.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Audrito:2022:XC" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
      </div>
      <div class="title">Functional Programming for Distributed Systems with XC</div>
      <div class="author">
        
          
          
          
          

          
            
              Giorgio Audrito, 
            
          
        
          
          
          
          

          
            
              Roberto Casadei, 
            
          
        
          
          
          
          

          
            
              Ferruccio Damiani, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mirko Viroli
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2022_Functional-Programming-for-Distributed-Systems-with-XC.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2022.20" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Programming distributed systems is notoriously hard due to – among the others – concurrency, asynchronous execution, message loss, and device failures. Homogeneous distributed systems consist of similar devices that communicate to neighbors and execute the same program: they include wireless sensor networks, network hardware and robot swarms. For the homogeneous case, we investigate an experimental language design that aims to push the abstraction boundaries farther, compared to existing approaches.</p><p>In this paper, we introduce the design of XC, a programming language to develop homogeneous distributed systems. In XC, developers define the single program that every device executes and the overall behavior is achieved collectively, in an emergent way. The programming framework transparently takes care of concurrency, asynchronous execution, message loss, and device failures. We propose a minimalistic design, which features a single declarative primitive for communication, state management and connection management. A mechanism called alignment enables developers to abstract over asynchronous execution while still retaining composability. We define syntax and operational semantics of a core calculus, prove a number of properties of the calculus, including type soundness. XC comes with two DSL implementations: a DSL in Scala and one in C++. An evaluation based on smart-city monitoring demonstrates XC in a realistic application.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Richter:2022:Prisma" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
      </div>
      <div class="title">Prisma: A Tierless Language for Enforcing Contract-client Protocols in Decentralized Apps</div>
      <div class="author">
        
          
          
          
          

          
            
              David Richter, 
            
          
        
          
          
          
          

          
            
              David Kretzler, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Sebastian Faust, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2022_Prisma-A-Tierless-Language-for-Enforcing-Contract-Client-Protocols-in-Decentralized-Applications.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2022.35" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Decentralized applications (dApps) consist of smart contracts that run on blockchains and clients that model collaborating parties. dApps are used to model financial and legal business functionality. Today, contracts and clients are written as separate programs – in different programming languages – communicating via send and receive operations. This makes distributed program flow awkward to express and reason about, increasing the potential for mismatches in the client-contract interface, which can be exploited by malicious clients, potentially leading to huge financial losses.</p><p>In this paper, we present Prisma, a language for tierless decentralized applications, where the contract and its clients are defined in one unit and pairs of send and receive actions that “belong together” are encapsulated into a single direct–style operation, which is executed differently by sending and receiving parties. This enables expressing distributed program flow via standard control flow and renders mismatching communication impossible. We prove formally that our compiler preserves program behavior in presence of an attacker controlling the client code. We systematically compare Prisma with mainstream and advanced programming models for dApps and provide empirical evidence for its expressiveness and performance.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2021:EssentialSafety" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICSE</abbr><br />
              
          
          
      </div>
      <div class="title">Change Is the Only Constant: Dynamic Updates for Workflows</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 44th International Conference on Software Engineering</em>, ICSE, 2022
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2022_Change-Is-the-Only-Constant-Dynamic-Updates-for-Workflows.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3510003.3510065" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
      
      <a href="https://doi.org/10.5281/zenodo.5864684" class="btn btn-sm z-depth-0" role="button" target="_blank">Supp</a>
      
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Software systems must be updated regularly to address changing requirements and urgent issues like security-related bugs. Traditionally, updates are performed by shutting down the system to replace certain components. In modern software organizations, updates are increasingly frequent—up to multiple times per day—hence, shutting down the entire system is unacceptable. Safe dynamic software updating (DSU) enables component updates while the system is running by determining when the update can occur without causing errors. Safe DSU is crucial, especially for long-running or frequently executed asynchronous transactions (workflows), e.g., user-interactive sessions and order fulfillment processes. Unfortunately, previous research is limited to synchronous transaction models and does not address this case.</p><p>In this work, we propose a unified model for safe DSU in workflows. We discuss how state-of-the-art DSU solutions fit into this model and show that they incur significant overhead. To improve the performance, we introduce Essential Safety, a novel safe DSU approach that leverages the notion of non-essential changes, i.e., semantics preserving updates. In 106 realistic collaborative BPMN workflows, Essential Safety reduces the delay of workflow completions, on average, by 47.8% compared to the state of the art. We show that the distinction of essential and non-essential changes plays a crucial role in this reduction and that, as suggested in literature, non-essential changes are frequent: at least 60% and often more than 90% of systems’ updates in eight monorepos we analyze.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2021</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Luthra:2021:TCEP" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">JCSS</abbr><br />
              
          
          
      </div>
      <div class="title">TCEP: Transitions in Operator Placement to Adapt to Dynamic Network Environments</div>
      <div class="author">
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          

          
            
              Niels Danger, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Ioannis Stavrakakis
            
          
        
      </div>

      <div class="periodical">
      
        <em>Journal of Computer and System Sciences</em> 122, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_TCEP-Transitions-in-Operator-Placement-to-Adapt-to-Dynamic-Network-Environments.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1016/j.jcss.2021.05.003" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed Complex Event Processing (DCEP) is a commonly used paradigm to detect and act on situational changes of many applications, including the Internet of Things (IoT). DCEP achieves this using a simple specification of analytical tasks on data streams called operators and their distributed execution on a set of infrastructure. The adaptivity of DCEP to the dynamics of IoT applications is essential and very challenging in the face of changing demands concerning Quality of Service. In our previous work, we addressed this issue by enabling transitions, which allow for the adaptive use of operator placement mechanisms. In this article, we extend the transition methodology by optimizing the costs of transition and analyzing the behavior using multiple operator placement mechanisms. Furthermore, we provide an extensive evaluation on the costs of transition imposed by operator migrations and learning, as it can inflict overhead on the performance if operated uncoordinatedly.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Oak:2021:Pavetrust" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PAVeTrust</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/je">J<sub>E</sub> <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Towards Democratizing Secure Enclave Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/oak">Aditya Oak</a>,
            
          
        
          
          
          
          

          
            
              Amir M. Ahmadian, 
            
          
        
          
          
          
          

          
            
              Musard Balliu, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Program Analysis and Verification on Trusted Platforms</em>, PAVeTrust, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Towards_Democratizing_Secure_Enclave_Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Secure enclaves, like Intel SGX, provide a means to process data securely on third-party cloud infrastructure with little or no performance overhead. Developing software that takes advantage of a secure enclave requires, however, to explicitly deal with a number of low-level details such as dedicated IO, custom syscalls, and stringent memory constraints, requiring the expertise needed for system programming, rather than applications. We discuss our recent research that provides a developer-friendly approach to enclave programming—our Java language extension JE. Finally, we outline our vision of a programming framework that brings secure enclave programming at the fingertips of application developers.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Oak:2021:EnclaveBased" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SecDev</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/je">J<sub>E</sub> <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Enclave-Based Secure Programming with JE</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/oak">Aditya Oak</a>,
            
          
        
          
          
          
          

          
            
              Amir M. Ahmadian, 
            
          
        
          
          
          
          

          
            
              Musard Balliu, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2021 IEEE Secure Development Conference</em>, SecDev, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Enclave-Based-Secure-Programming-with-JE.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/SecDev51306.2021.00026" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Over the past few years, major hardware vendors have started offering processors that support Trusted Execution Environments (TEEs) allowing confidential computations over sensitive data on untrusted hosts. Unfortunately, developing applications that use TEEs remains challenging. Current solutions require to use low-level languages (e.g., C/C++) to handle the TEE management process manually – a complex and error-prone task. Worse, the separation of the application into components that run inside and outside the TEE may lead to information leaks. In summary, TEEs are a powerful means to design secure applications, but there is still a long way to building secure software with TEEs alone.</p><p>In this work, we present , a programming model for developing TEE-enabled applications where developers only need to annotate Java programs to define application-level security policies and run them securely inside enclaves.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2021:Automating" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ESEC/FSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/mjuz">µs <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Automating Serverless Deployments for DevOps Organizations</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, ESEC/FSE, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Automating-Serverless-Deployments-for-DevOps-Organizations.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3468264.3468575" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
      
      <a href="https://doi.org/10.5281/zenodo.4888908" class="btn btn-sm z-depth-0" role="button" target="_blank">Supp</a>
      
    
    
    
      <a href="https://github.com/mjuz-iac/mjuz" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>DevOps unifies software development and operations in cross-functional teams to improve software delivery and operations (SDO) performance. Ideally, cross-functional DevOps teams independently deploy their services, but the correct operation of a service often demands other services, requiring coordination to ensure the correct deployment order. This issue is currently solved either with a central deployment or manual out-of-band communication across teams, e.g., via phone, chat, or email. Unfortunately, both contradict the independence of teams, hindering SDO performance – the reason why DevOps is adopted in the first place.</p><p>In this work, we conduct a study on 73 IT professionals, showing that, in practice, they resort to manual coordination for correct deployments even if they expect better SDO performance with fully automated approaches. To address this issue, we propose μs ([mju:z] “muse”), a novel IaC system automating deployment coordination in a fully decentralized fashion, still retaining compatibility with DevOps practice – in contrast to today’s solutions. We implement µs, demonstrate that it effectively enables automated coordination, introduces negligible definition overhead, has no performance overhead, and is broadly applicable, as shown by the migration of 64 third-party IaC projects.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2021:Deployment" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ESEC/FSE DS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/mjuz">µs <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Deployment Coordination for Cross-Functional DevOps Teams</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, ESEC/FSE, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Deployment-Coordination-for-Cross-Functional-DevOps-Teams.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3468264.3473101" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Software stability and reliability are the core concerns of DevOps. They are improved by tightening the collaboration between developers and operators in cross-functional teams on the one hand and by automating operations through continuous integration (CI) and infrastructure as code (IaC) on the other hand. Ideally, teams in DevOps are fully independent. Still, their applications often depend on each other in practice, requiring them to coordinate their deployment through centralization or manual coordination.</p><p>With this work, we propose and implement the novel IaC solution µs ([mju:z] “muse”), which automates deployment coordination in a decentralized fashion. µs is the first approach that is compatible with the DevOps goals as it enables truly independent operations of the DevOps teams. We define our research problem through a questionnaire survey with IT professionals and evaluate the solution by comparing it to other modern IaC approaches, assessing its performance, and applying it to existing IaC programs.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sztwiertnia:2021:Impact" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">AISTA</abbr><br />
              
          
          
      </div>
      <div class="title">Impact of Programming Languages on Machine Learning Bugs</div>
      <div class="author">
        
          
          
          
          

          
            
              Sebastian Sztwiertnia, 
            
          
        
          
          
          
          

          
            
              Maximilian Grübel, 
            
          
        
          
          
          
          

          
            
              Amine Chouchane, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          

          
            
              Krishna Narasimhan, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 1st ACM International Workshop on AI and Software Testing/Analysis</em>, AISTA, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Impact-of-Programming-Languages-on-Machine-Learning-Bugs.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3464968.3468408" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Machine learning (ML) is on the rise to be ubiquitous in modern software. Still, its use is challenging for software developers. So far, research has focused on the ML libraries to find and mitigate these challenges. However, there is initial evidence that programming languages also add to the challenges, identifiable in different distributions of bugs in ML programs. To fill this research gap, we propose the first empirical study on the impact of programming languages on bugs in ML programs. We plan to analyze software from GitHub and related discussions in GitHub issues and Stack Overflow for bug distributions in ML programs, aiming to identify correlations with the chosen programming language, its features and the application domain. This study’s results enable better-targeted use of available programming language technology in ML programs, preventing bugs, reducing errors and speeding up development.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Giallorenzo:2021:Multiparty" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multiparty Languages: The Choreographic and Multitier Cases</div>
      <div class="author">
        
          
          
          
          

          
            
              Saverio Giallorenzo, 
            
          
        
          
          
          
          

          
            
              Fabrizio Montesi, 
            
          
        
          
          
          
          

          
            
              Marco Peressotti, 
            
          
        
          
          
          
          

          
            
              David Richter, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 35th European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Multiparty-Languages-The-Choreographic-and-Multitier-Cases.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2021.22" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Choreographic languages aim to express multiparty communication protocols, by providing primitives that make interaction manifest. Multitier languages enable programming computation that spans across several tiers of a distributed system, by supporting primitives that allow computation to change the location of execution. Rooted into different theoretical underpinnings—respectively process calculi and lambda calculus—the two paradigms have been investigated independently by different research communities with little or no contact. As a result, the link between the two paradigms has remained hidden for long.</p><p>In this paper, we show that choreographic languages and multitier languages are surprisingly similar. We substantiate our claim by isolating the core abstractions that differentiate the two approaches and by providing algorithms that translate one into the other in a straightforward way. We believe that this work paves the way for joint research and cross-fertilisation among the two communities.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Oak:2021:Language" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">CSF</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/je">J<sub>E</sub> <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Language Support for Secure Software Development with Enclaves</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/oak">Aditya Oak</a>,
            
          
        
          
          
          
          

          
            
              Amir M. Ahmadian, 
            
          
        
          
          
          
          

          
            
              Musard Balliu, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 34th IEEE Computer Security Foundations Symposium</em>, CSF, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Language-Support-for-Secure-Software-Development-with-Enclaves.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/CSF51468.2021.00037" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Confidential computing is a promising technology for securing code and data-in-use on untrusted host machines, e.g., the cloud. Many hardware vendors offer different implementations of Trusted Execution Environments (TEEs). A TEE is a hardware protected execution environment that allows performing confidential computations over sensitive data on untrusted hosts. Despite the appeal of achieving strong security guarantees against low-level attackers, two challenges hinder the adoption of TEEs. First, developing software in high-level managed languages, e.g., Java or Scala, taking advantage of existing TEEs is complex and error-prone. Second, partitioning an application into components that run inside and outside a TEE may break application-level security policies, resulting in an insecure application when facing a realistic attacker.</p><p>In this work, we study both these challenges. We present J<sub>E</sub>, a programming model that seamlessly integrates a TEE, abstracting away low-level programming details such as initialization and loading of data into the TEE. J<sub>E</sub> only requires developers to add annotations to their programs to enable the execution within the TEE. Drawing on information flow control, we develop a security type system that checks confidentiality and integrity policies against realistic attackers with full control over the code running outside the TEE. We formalize the security type system for the J<sub>E</sub> core and prove it sound for a semantic characterization of security. We implement J<sub>E</sub> and the security type system, enable Java programs to run on Intel SGX with strong security guarantees. We evaluate our approach on use cases from the literature, including a battleship game, a secure event processing system, and a popular processing framework for big data, showing that we correctly handle complex cases of partitioning, information flow, declassification, and trust.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Eskandani:2021:Wonderless" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">MSR</abbr><br />
              
          
          
      </div>
      <div class="title">The Wonderless Dataset for Serverless Computing</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/eskandani">Nafise Eskandani</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the IEEE/ACM 18th International Conference on Mining Software Repositories</em>, MSR, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_The-wonderless-Dataset-for-Serverless-Computing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/MSR52588.2021.00075" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Function as a Service (FaaS) has grown in popularity in recent years, with an increasing number of applications following the Serverless computing model. Serverless computing supports out of the box autoscaling in a pay-as-you-go manner, letting developers focus on the application logic rather than worrying about resource management. With the increasing adoption of the this model, researchers have started studying a wide variety of aspects of Serverless computing, including communication, security, performance, and cost optimization. Yet, we still know very little of how Serverless computing is used in practice.</p><p>In this paper, we introduce Wonderless, a novel dataset of open-source Serverless applications. Wonderless consists of 1,877 real-world Serverless applications extracted from GitHub, and it can be used as a data source for further research in the Serverless ecosystem, such as performance evaluation and software mining. To the best of our knowledge, Wonderless is currently the most diverse and largest dataset for research on Serverless computing.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2020</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Zhang:2020:Handling" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
      </div>
      <div class="title">Handling Bidirectional Control Flow</div>
      <div class="author">
        
          
          
          
          

          
            
              Yizhou Zhang, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Andrew C. Myers
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 4 (OOPSLA), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3428207" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage.</p><p>We introduce <i>bidirectional algebraic effects</i>, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.</p><p>The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2020:Leveraging" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SuperCompCloud</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Leveraging Hybrid Cloud HPC with Multitier Reactive Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          

          
            
              Jan-Patrick Lehr, 
            
          
        
          
          
          
          

          
            
              Christian Bischof, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 3rd IEEE/ACM International Workshop on Interoperability of Supercomputing and Cloud Technologies</em>, SuperCompCloud, 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_Leveraging-Hybrid-Cloud-HPC-with-Multitier-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/SuperCompCloud51944.2020.00010" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The advent of cloud computing has enabled large-scale availability of on-demand computing and storage resources. However, these benefits are not yet at the fingertips of HPC developers: Typical HPC applications use on-premise computing resources and rely on static deployment setups, reliable hardware, and rather homogeneous resources. This hinders (partial) execution in the cloud, even though applications could benefit from scaling beyond on-premise resources and from the variety of hardware available in the cloud to speed up execution.</p><p>To address this issue, we orchestrate computationally intensive kernels using a high-level programming language that ensures advanced optimization and improves execution flexibility-enabling hybrid cloud/on-premise HPC deployments. Our approach is based on multitier reactive programming, where distributed code is defined within the same compilation unit and computations are placed explicitly using placement types. We adjust placement based on performance characteristics measured before execution, apply our approach to a shortest vector problem (SVP) solver from cryptanalysis, and evaluate it to be effective.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Köhler:2020:Rethinking" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Rethinking Safe Consistency in Distributed Object-Oriented Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/eskandani">Nafise Eskandani</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 4 (OOPSLA), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_Rethinking-Safe-Consistency-In-Distributed-Object-Oriented-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3428256" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files.</p><p>In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Survey" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">CSUR</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">A Survey of Multitier Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Johannes Wirth, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>ACM Computing Surveys</em> 53 (4), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_A-Survey-of-Multitier-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3397495" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming deals with developing the components that pertain to different tiers in the system (e.g., client and server), mixing them in the same compilation unit. In this paradigm, the code for different tiers is then either generated at run time or it results from the compiler splitting the codebase into components that belong to different tiers based on user annotations, static analysis, types, or a combination of these. In the Web context, multitier languages aim at reducing the distinction between client and server code, by translating the code that is to be executed on the clients to JavaScript or by executing JavaScript on the server, too. Ultimately, the goal of the multitier approach is to improve program comprehension, simplify maintenance and enable formal reasoning about the properties of the whole distributed application.</p><p>A number of multitier research languages have been proposed over the last decade, which support various degrees of multitier programming and explore different design tradeoffs. In this article, we provide an overview of the existing solutions, discuss their positioning in the design space, and outline open research problems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Helm:2020:Programming" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ISSTA</abbr><br />
              
          
          
      </div>
      <div class="title">A Programming Model for Semi-Implicit Parallelization of Static Analyses</div>
      <div class="author">
        
          
          
          
          

          
            
              Dominik Helm, 
            
          
        
          
          
          
          

          
            
              Florian Kübler, 
            
          
        
          
          
          
          

          
            
              Jan Thomas Kölzer, 
            
          
        
          
          
          
          

          
            
              Philipp Haller, 
            
          
        
          
          
          
          

          
            
              Michael Eichberg, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis</em>, ISSTA, 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3395363.3397367" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal- yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Köhler:2020:ConSysT" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FTfJP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">ConSysT: Tunable, Safe Consistency Meets Object-Oriented Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/eskandani">Nafise Eskandani</a>,
            
          
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 22nd ACM SIGPLAN International Workshop on Formal Techniques for Java-Like Programs</em>, FTfJP, 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3427761.3428346" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Data replication is essential in scenarios like geo-distributed datacenters, but poses challenges for data consistency. Developers adopt Strong consistency at the cost of performance or embrace Weak consistency and face a higher programming complexity. We argue that languages should associate consistency to data types. We present , a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can only be mixed correctly.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Implementing" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">‹Programming›</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Implementing a Language for Distributed Systems: Choices and Experiences with Type Level and Macro Programming in Scala</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>The Art, Science, and Engineering of Programming</em> 4 (3), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_Implementing-a-Language-for-Distributed-Systems.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.22152/programming-journal.org/2020/4/17" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming languages reduce the complexity of developing distributed systems by developing the distributed system in a single coherent code base. The compiler or the runtime separate the code for the components of the distributed system, enabling abstraction over low level implementation details such as data representation, serialization and network protocols. Our ScalaLoci language allows developers to declare the different components and their architectural relation at the type level, allowing static reasoning about about distribution and remote communication and guaranteeing static type safety across components. The compiler splits the multitier program into the component-specific code and automatically generates the communication boilerplate. Communication between components can be modeled by declaratively specifying data flows between components using reactive programming.</p><p>In this paper, we report on the implementation of our design and our experience with embedding our language features into Scala as a host language. We show how a combination of Scala’s advanced type level programming and its macro system can be used to enrich the language with new abstractions. We comment on the challenges we encountered and the solutions we developed for our current implementation and outline suggestions for an improved macro system to support the such use cases of embedding of domain-specific abstractions.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Programming" class="col-sm-12">
    
      <div class="abbr">
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">A Programming Language for Distributed Systems</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
          Doctoral dissertation, <em>Technische Universität Darmstadt</em>, 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.25534/tuprints-00013500" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Today’s software, including many everyday services, such as online streaming, search engines and social networks, is widely distributed, running on top of a network of interconnected computers. Such distributed applications are traditionally developed as separate modules for each component in the distributed system. These modules react to events, like user input or messages from the network, and in turn produce new events for the other modules. Separation into different modules is problematic because combining modules is notoriously hard and requires extensive and time-consuming integration and manual implementation of communication forces programmers to program complex event-based communication schemes among hosts ? an activity which is often low-level and error-prone. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. For these reasons, despite most software today is distributed, the design and development of distributed systems remains surprisingly challenging.</p><p>We present the ScalaLoci distributed programming language, our approach for taming the complexity of developing distributed applications via specialized programming language support. ScalaLoci addresses the issues above with a coherent model based on placement types that enables reasoning about distributed data flows otherwise scattered across multiple modules, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions.</p><p>ScalaLoci does not force developers to modularize software along network boundaries as is traditionally the case when developing distributed systems. Instead, we propose a module system that supports encapsulating each (cross-host) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of ScalaLoci modules, each representing a subsystem.</p><p>Our case studies on distributed algorithms, distributed data structures, as well as on real-world distributed streaming engines show that ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs. As we demonstrate, the ScalaLoci module system allows the definition of reusable patterns of interaction in distributed software and enables separating the modularization and distribution concerns, properly separating functionalities in distributed systems.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2019</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Köhler:2019:Automated" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ASE</abbr><br />
              
          
          
      </div>
      <div class="title">Automated Refactoring to Reactive Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering</em>, ASE, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Automated-Refactoring-to-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/ASE.2019.00082" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive programming languages and libraries, such as ReactiveX, have been shown to significantly improve software design and have seen important industrial adoption over the last years. Asynchronous applications - which are notoriously error-prone to implement and to maintain - greatly benefit from reactive programming because they can be defined in a declarative style, which improves code clarity and extensibility.</p><p>In this paper, we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming. We propose 2Rx, a refactoring approach to automatically convert asynchronous code to reactive programming. Our evaluation on top-starred GitHub projects shows that 2Rx is effective with common asynchronous constructs and it can provide a refactoring for 91.7% of their occurrences.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Schindelhauer:2019:Collaborative" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ALGOSENSORS</abbr><br />
              
          
          
      </div>
      <div class="title">Collaborative Broadcast in 𝓞(log log n) Rounds</div>
      <div class="author">
        
          
          
          
          

          
            
              Christian Schindelhauer, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/oak">Aditya Oak</a>,
            
          
        
          
          
          
          

          
            
              Thomas Janson
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the International Symposium on Algorithms and Experiments for Sensor Systems, Wireless Networks and Distributed Robotics</em>, ALGOSENSORS, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1007/978-3-030-34405-4_7" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We consider the multihop broadcasting problem for n nodes placed uniformly at random in a disk and investigate the number of hops required to transmit a signal from the central node to all other nodes under three communication models: Unit-Disk-Graph (UDG), Signal-to-Noise-Ratio (SNR), and the wave superposition model of multiple input/multiple output (MIMO).</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Mogk:2019:FaultTolerant" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">A Fault-Tolerant Programming Model for Distributed Interactive Applications</div>
      <div class="author">
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          

          
            
              Joscha Drechsler, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 3 (OOPSLA), 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3360570" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Ubiquitous connectivity of web, mobile, and IoT computing platforms has fostered a variety of distributed applications with decentralized state. These applications execute across multiple devices with varying reliability and connectivity. Unfortunately, there is no declarative fault-tolerant programming model for distributed interactive applications with an inherently decentralized system model.</p><p>We present a novel approach to automating fault tolerance using high-level programming abstractions tailored to the needs of distributed interactive applications. Specifically, we propose a calculus that enables formal reasoning about applications’ dataflow within and across individual devices. Our calculus reinterprets the functional reactive programming model to seamlessly integrate its automated state change propagation with automated crash recovery of device-local dataflow and disconnection-tolerant distribution with guaranteed automated eventual consistency semantics based on conflict-free replicated datatypes. As a result, programmers are relieved of handling intricate details of distributing change propagation and coping with distribution failures in the presence of interactivity. We also provides proofs of our claims, an implementation of our calculus, and an empirical evaluation using a common interactive application.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Eskandani:2019:Distributed" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SPLASH Companion</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Distributed Object-Oriented Programming with Multiple Consistency Levels in ConSysT</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/eskandani">Nafise Eskandani</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</em>, SPLASH Companion, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3359061.3362779" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Data replication is essential in scenarios like geo-distributed datacenters and edge computing. Yet, it poses a challenge for data consistency. Developers either adopt high consistency at the detriment of performance or they embrace low consistency and face a much higher programming complexity. We argue that language abstractions should support associating the level of consistency to data types. We present ConSysT, a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can be mixed only in a correct way.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Blöcher:2019:Grass" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">REBLS</abbr><br />
              
          
          
      </div>
      <div class="title">GRASS: Generic Reactive Application-Specific Scheduling</div>
      <div class="author">
        
          
          
          
          

          
            
              Marcel Blöcher, 
            
          
        
          
          
          
          

          
            
              Matthias Eichholz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Patrick Eugster, 
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 6th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems</em>, REBLS, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_GRASS-Generic-Reactive-Application-Specific-Scheduling.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3358503.3361274" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>High resource utilization is important to operate compute infrastructures and data centers efficiently. High utilization is achieved by multiplexing several applications over the same physical infrastructure. Yet, with this approach, the different requirements of each application have to be taken into account when scheduling resources.</p><p>We propose GRASS, a reactive domain-specific abstraction that allows specifying application-tailored resource scheduling policies. We demonstrate how the declarative approach of GRASS enables extension and composition of scheduling policies. Our evaluation shows the performance benefits of considering application-specific information in a composition of scheduling policies that adapt at run time.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2019:LanguageIntegrated" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
      </div>
      <div class="title">Language-Integrated Privacy-Aware Distributed Queries</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          

          
            
              Philipp Haller, 
            
          
        
          
          
          
          

          
            
              Sebastian Erdweg, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 3 (OOPSLA), 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Language-Integrated-Privacy-Aware-Distributed-Queries.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3360593" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed query processing is an effective means for processing large amounts of data. To abstract from the technicalities of distributed systems, algorithms for operator placement automatically distribute sequential data queries over the available processing units. However, current algorithms for operator placement focus on performance and ignore privacy concerns that arise when handling sensitive data.</p><p>We present a new methodology for privacy-aware operator placement that both prevents leakage of sensitive information and improves performance. Crucially, our approach is based on an information-flow type system for data queries to reason about the sensitivity of query subcomputations. Our solution unfolds in two phases. First, placement space reduction generates deployment candidates based on privacy constraints using a syntax-directed transformation driven by the information-flow type system. Second, constraint solving selects the best placement among the candidates based on a cost model that maximizes performance. We verify that our algorithm preserves the sequential behavior of queries and prevents leakage of sensitive data. We implemented the type system and placement algorithm for a new query language SecQL and demonstrate significant performance improvements in benchmarks.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2019:Multitier" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">REBLS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multitier Reactive Programming in High Performance Computing</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          

          
            
              Philipp Martens, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Presentation at the 6th Workshop on Reactive and Event-based Languages and Systems (REBLS)</em>, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Multitier-Reactive-Programming-in-High-Performance-Computing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>High Performance Computing (HPC) is crucial in a number of sectors, including weather forecasts, particle simulations and fluid dynamics. Existing programming frameworks for HPC expose developers to low-level details such as message passing and explicit memory management, which are hard to program and error-prone.</p><p>In this paper, we present ongoing work on increasing the level of abstraction for HPC. We tackle this problem with an approach based on a combination of multitier programming and reactive programming which enables the development of complex processor configurations in a uniform way using event streams as communication pattern. We report our experience with LULESH, a well known HPC benchmark, and we outline our research roadmap.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Baumgärtner:2019:Smart" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">GHTC</abbr><br />
              
          
          
      </div>
      <div class="title">Smart Street Lights and Mobile Citizen Apps for Resilient Communication in a Digital City</div>
      <div class="author">
        
          
          
          
          

          
            
              Lars Baumgärtner, 
            
          
        
          
          
          
          

          
            
              Jonas Höchst, 
            
          
        
          
          
          
          

          
            
              Patrick Lampe, 
            
          
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          

          
            
              Artur Sterz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          

          
            
              Bernd Freisleben
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2019 IEEE Global Humanitarian Technology Conference</em>, GHTC, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Smart-Street-Lights-and-Mobile-Citizen-Apps-for-Resilient-Communication-in-a-Digital-City.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/GHTC46095.2019.9033134" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>While information and communication technology is crucial for the operation of urban infrastructures and the well-being of its inhabitants, current technology is quite vulnerable to disruptions of various kinds. In future smart cities, a more resilient urban infrastructure is imperative to handle the increasing number of hazardous situations. We present a novel resilient communication approach based on smart street lights as part of the public infrastructure. It supports people in their everyday life and adapts its functionality to the challenges of emergency situations. Our approach relies on various environmental sensors and in-situ processing for automatic situation assessment, and a range of communication mechanisms for maintaining a communication network. Furthermore, resilience is not only achieved based on infrastructure deployed by a digital city’s municipality, but also based on integrating citizens through software that runs on their mobile devices. Web-based zero-installation and platform-agnostic apps can switch to device-to-device communication to continue benefiting people even during a disaster situation. Our approach, featuring a covert channel for professional responders and a zero-installation app, is evaluated through a prototypical implementation based on a commercially available street light.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Eichholz:2019:TypeSafe" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
      </div>
      <div class="title">How to Avoid Making a Billion-Dollar Mistake: Type-Safe Data Plane Programming with SafeP4</div>
      <div class="author">
        
          
          
          
          

          
            
              Matthias Eichholz, 
            
          
        
          
          
          
          

          
            
              Eric Campbell, 
            
          
        
          
          
          
          

          
            
              Nate Foster, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 33rd European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2019.12" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The P4 programming language offers high-level, declarative abstractions that bring the flexibility of software to the domain of networking. Unfortunately, the main abstraction used to represent packet data in P4, namely header types, lacks basic safety guarantees. Over the last few years, experience with an increasing number of programs has shown the risks of the unsafe approach, which often leads to subtle software bugs.</p><p>This paper proposes SafeP4, a domain-specific language for programmable data planes in which all packet data is guaranteed to have a well-defined meaning and satisfy essential safety guarantees. We equip SafeP4 with a formal semantics and a static type system that statically guarantees header validity – a common source of safety bugs according to our analysis of real-world P4 programs. Statically ensuring header validity is challenging because the set of valid headers can be modified at runtime, making it a dynamic program property. Our type system achieves static safety by using a form of path-sensitive reasoning that tracks dynamic information from conditional statements, routing tables, and the control plane. Our evaluation shows that SafeP4’s type system can effectively eliminate common failures in many real-world programs.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2019:Multitier" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multitier Modules</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 33rd European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Multitier-Modules.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2019.3" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming languages address the complexity of developing distributed systems abstracting over low level implementation details such as data representation, serialization and network protocols. Since the functionalities of different peers can be defined in the same compilation unit, multitier languages do not force developers to modularize software along network boundaries. Unfortunately, combining the code for all tiers into the same compilation unit poses a scalability challenge or forces developers to resort to traditional modularization abstractions that are agnostic to the multitier nature of the language.</p><p>In this paper, we address this issue with a module system for multitier languages. Our module system supports encapsulating each (cross-peer) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of multitier modules, each representing a subsystem. Our case studies on distributed algorithms, distributed data structures, as well as on the Apache Flink task distribution system, show that multitier modules allow the definition of reusable (abstract) patterns of interaction in distributed software and enable separating the modularization and distribution concerns, properly separating functionalities in distributed systems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Bračevac:2019:TypeSafe" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">CoRR</abbr><br />
              
          
          
      </div>
      <div class="title">Type-safe, Polyvariadic Event Correlation</div>
      <div class="author">
        
          
          
          
          

          
            
              Oliver Bračevac, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Sebastian Erdweg, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
          arXiv, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://arxiv.org/abs/1907.02990" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The pivotal role that event correlation technology plays in todays applications has lead to the emergence of different families of event correlation approaches with a multitude of specialized correlation semantics, including computation models that support the composition and extension of different semantics.</p><p>However, type-safe embeddings of extensible and composable event patterns into statically-typed generalpurpose programming languages have not been systematically explored so far. This is unfortunate, as typesafe embedding of event patterns is important to enable increased correctness of event correlation computations as well as domain-specific optimizations. Event correlation technology has often adopted well-known and intuitive notations from database queries, for which approaches to type-safe embedding do exist. However, we argue in the paper that these approaches, which are essentially descendants of the work on monadic comprehensions, are not well-suited for event correlations and, thus, cannot without further ado be reused/repurposed for embedding event patterns.</p><p>To close this gap we propose PolyJoin, a novel approach to type-safe embedding for fully polyvariadic event patterns with polymorphic correlation semantics. Our approach is based on a tagless final encoding with uncurried higher-order abstract syntax (HOAS) representation of event patterns withn variables, for arbitrary n ∈ ℕ. Thus, our embedding is defined in terms of the host language without code generation and exploits the host language type system to model and type check the type system of the pattern language. Hence, by construction it impossible to define ill-typed patterns. We show that it is possible to have a purely <i>library-level</i> embedding of event patterns, in the familiar join query notation, which is not restricted to monads. PolyJoin is practical, type-safe and extensible. An implementation of it in pure multicore OCaml is readily usable.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Casadei:2019:ContextOrientation" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FAS*W</abbr><br />
              
          
          
      </div>
      <div class="title">On Context-Orientation in Aggregate Programming</div>
      <div class="author">
        
          
          
          
          

          
            
              Roberto Casadei, 
            
          
        
          
          
          
          

          
            
              Danilo Pianini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mirko Viroli
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2019 IEEE 4th International Workshops on Foundations and Applications of Self* Systems</em>, FAS*W, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1109/FAS-W.2019.00035" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Context-awareness plays a central role in selfadaptive software. By a programming perspective, context is often used implicitly, and context-aware code is fragmented in the codebase. In Context-Oriented Programming, instead, context is considered a first-class citizen and is explicitly used to modularise context-sensitive functionality and behavioural variability. In this paper, we reflect on the role of context in collective adaptive systems, by a discussion from the special perspective of a macro paradigm, Aggregate Programming, which supports the specification of collective behaviour by a global perspective through functional compositions of field computations. In particular, we consider the abstractions exposed in Context-Oriented and Aggregate Programming, suggest potential synergies in both directions, and accordingly take the first steps towards a combined design</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2019:Developing" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Tutorial: Developing Distributed Systems with Multitier Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 13th ACM International Conference on Distributed and Event-Based Systems</em>, DEBS, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Developing-Distributed-Systems-with-Multitier-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3328905.3332465" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Developing distributed systems is a complex task that requires to program different peers, often using several languages on different platforms, writing communication code and handling data serialization and conversion.</p><p>We show how the multitier programming paradigm can alleviate these issues, supporting a development model where all peers in the system can be written in the same language and coexist in the same compilation units, communication code is automatically inserted by the compiler and the language abstracts over data conversion and serialization. We present multitier programming abstractions, discuss their applicability step by step for the development of small applications and discuss larger case studies on distributed stream processing, like Apache Flink and Apache Gearpump.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Oak:2019:Language" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PASS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/je">J<sub>E</sub> <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Language Support for Multiple Privacy Enhancing Technologies</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/oak">Aditya Oak</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings of the 3rd International Conference on Art, Science, and Engineering of Programming</em>, ‹Programming› Companion, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3328433.3328446" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Privacy is one of the critical aspects in the design of computing systems. Various techniques are being used to enforce privacy, such as information flow control, symmetric/asymmetric cryptography, secure computing enclaves, partial homomorphic encryption and differential privacy. These mechanisms should ideally be combined in complex software systems as they offer different properties and performance trade offs. Unfortunately, reasoning about the privacy properties of such combination is still an open research problem.</p><p>In this paper, we present our vision on a programming language in which we incorporate different privacy preservation techniques in a common programming model.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2018</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Weisenburger:2018:Distributed" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Distributed System Development with ScalaLoci</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 2 (OOPSLA), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_Distributed-System-Development-with-ScalaLoci.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3276499" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed applications are traditionally developed as separate modules, often in different languages, which react to events, like user input, and in turn produce new events for the other modules. Separation into components requires time-consuming integration. Manual implementation of communication forces programmers to deal with low-level details. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. The ScalaLoci distributed programming language addresses these issues with a coherent model based on placement types that enables reasoning about distributed data flows, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions. As we show, ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Drechsler:2018:ThreadSafe" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Thread-Safe Reactive Programming</div>
      <div class="author">
        
          
          
          
          

          
            
              Joscha Drechsler, 
            
          
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 2 (OOPSLA), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018-Thread-safe-reactive-programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3276477" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The execution of an application written in a reactive language involves transfer of data and control flow between imperative and reactive abstractions at well-defined points. In a multi-threaded environment, multiple such interactions may execute concurrently, potentially causing data races and event ordering ambiguities. Existing RP languages either disable multi-threading or handle it at the cost of reducing expressiveness or weakening consistency. This paper proposes a model for thread-safe reactive programming (RP) that ensures abort-free strict serializability under concurrency while sacrificing neither expressiveness nor consistency. We also propose an architecture for integrating a corresponding scheduler into the RP language runtime, such that thread-safety is provided "out-of-the-box" to the applications.</p><p>We show the feasibility of our proposal by providing and evaluating a ready-to-use implementation integrated into the REScala programming language. The scheduling algorithm is formally proven correct. A thorough empirical evaluation shows that reactive applications build on top of it scale with multiple threads, while the scheduler incurs acceptable performance overhead in a single-threaded configuration. The scalability enabled by our scheduler is roughly on-par with that of hand-crafted application-specific locking and better than the scalability enabled by a scheduler using an off-the-shelf software transactional memory library.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Mogk:2018:FaultTolerant" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Fault-tolerant Distributed Reactive Programming</div>
      <div class="author">
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          

          
            
              Lars Baumgärtner, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Bernd Freisleben, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 32nd European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_Fault-tolerant-Distributed-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2018.1" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>In this paper, we present a holistic approach to provide fault tolerance for distributed reactive programming. Our solution automatically stores and recovers program state to handle crashes, automatically updates and shares distributed parts of the state to provide eventual consistency, and handles errors in a fine-grained manner to allow precise manual control when necessary. By making use of the reactive programming paradigm, we provide these mechanisms without changing the behavior of existing programs and with reasonable performance, as indicated by our experimental evaluation.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Eichberg:2018:Lattice" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SOAP</abbr><br />
              
          
          
      </div>
      <div class="title">Lattice Based Modularization of Static Analyses</div>
      <div class="author">
        
          
          
          
          

          
            
              Michael Eichberg, 
            
          
        
          
          
          
          

          
            
              Florian Kübler, 
            
          
        
          
          
          
          

          
            
              Dominik Helm, 
            
          
        
          
          
          
          

          
            
              Michael Reif, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings for the ISSTA/ECOOP 2018 Workshops</em>, ISSTA/ECOOP Companion, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3236454.3236509" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Static analyses which compute conceptually independent information, e.g., class immutability or method purity are typically developed as standalone, closed analyses. Complementary information that could improve the analyses is either ignored by making a sound over-approximation or it is also computed by the analyses, but at a rudimentary level. For example, an immutability analysis requires field mutability information, alias/escape information, and information about the concurrent behavior of methods to correctly classify classes like java.lang.String or java.util.BigDecimal. As a result, without properly supporting the integration of independently developed, mutually benefiting analysis, many analyses will not correctly classify relevant entities.We propose to use explicitly reified lattices that encode the information about a source code element’s properties (e.g., a method’s purity or a class’ immutability) as the sole interface between mutually dependent analyses. This enables the composition of multiple analyses. Our case study shows that using such an approach enables highly scalable, lightweight implementations of modularized static analyses.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2018:Static" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FTfJP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Static Latency Tracking with Placement Types</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Tobias Reinhard, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings for the ISSTA/ECOOP 2018 Workshops</em>, ISSTA/ECOOP Companion, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_Static-Latency-Tracking-with-Placement-Types.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3236454.3236486" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Large-scale distributed applications, e.g., in geodistributed data centers, pose a performance challenge to developers which need to take high cross-data-center latency communication cost into account. We present a preliminary investigation of a type system that tracks latency and makes the cost of remote calls explicit, raising developers’ awareness of communication overhead.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Bračevac:2018:Versatile" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICFP</abbr><br />
              
          
          
      </div>
      <div class="title">Versatile Event Correlation with Algebraic Effects</div>
      <div class="author">
        
          
          
          
          

          
            
              Oliver Bračevac, 
            
          
        
          
          
          
          

          
            
              Nada Amin, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Sebastian Erdweg, 
            
          
        
          
          
          
          

          
            
              Patrick Eugster, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 2 (ICFP), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018-Versatile-event-correlation-with-algebraic-effects.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3236762" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>We present the first language design to uniformly express variants of n-way joins over asynchronous event streams from different domains, e.g., stream-relational algebra, event processing, reactive and concurrent programming. We model asynchronous reactive programs and joins in direct style, on top of algebraic effects and handlers. Effect handlers act as modular interpreters of event notifications, enabling fine-grained control abstractions and customizable event matching. Join variants can be considered as cartesian product computations with “degenerate” control flow, such that unnecessary tuples are not materialized a priori. Based on this computational interpretation, we decompose joins into a generic, naïve enumeration procedure of the cartesian product, plus variant-specific extensions, represented in terms of user-supplied effect handlers. Our microbenchmarks validate that this extensible design avoids needless materialization. Alongside a formal semantics for joining and prototypes in Koka and multicore OCaml, we contribute a systematic comparison of the covered domains and features.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Graubner:2018:Multimodal" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
      </div>
      <div class="title">Multimodal Complex Event Processing on Mobile Devices</div>
      <div class="author">
        
          
          
          
          

          
            
              Pablo Graubner, 
            
          
        
          
          
          
          

          
            
              Christoph Thelen, 
            
          
        
          
          
          
          

          
            
              Michael Körber, 
            
          
        
          
          
          
          

          
            
              Artur Sterz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          

          
            
              Bernhard Seeger, 
            
          
        
          
          
          
          

          
            
              Bernd Freisleben
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems</em>, DEBS, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3210284.3210289" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Mobile devices are increasingly being used in edge and fog computing environments to process contextual data collected by sensors. Although complex event processing (CEP) is a suitable approach for realizing context-aware services on mobile devices in these environments, existing mobile CEP engines do not leverage the full potential of modern mobile hardware/software architectures. In this paper, we present multimodal CEP, a novel approach to process streams of events on-device in user space (user mode), in the operating system (kernel mode), on the Wi-Fi chip (Wi-Fi mode), and/or on a sensor hub (hub mode), providing significant improvements in terms of power consumption and throughput. Multimodal CEP automatically breaks up CEP queries and selects the most adequate execution mode for the involved CEP operators. Filter, aggregation, and correlation operators can be expressed in a high-level language without requiring system-level domain-specific knowledge. Multimodal CEP enables developers to efficiently detect user activities, collect environmental conditions, or interpret operating system and network events. Furthermore, it facilitates novel context-aware services, demonstrated by a use case for gathering and analyzing mobility data by Wi-Fi probe request tracking.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Luthra:2018:TCEP" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
      </div>
      <div class="title">TCEP: Adapting to Dynamic User Environments by Enabling Transitions between Operator Placement Mechanisms</div>
      <div class="author">
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Raheel Arif
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems</em>, DEBS, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_TCEP-Adapting-to-Dynamic-User-Environments-by-Enabling-Transitions-between-Operator-Placement-Mechanisms.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3210284.3210292" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Operator placement has a profound impact on the performance of a distributed complex event processing system (DCEP). Since the behavior of a placement mechanism strongly depends on its environment; a single placement mechanism is often not enough to fulfill stringent performance requirements under environmental changes. In this paper, we show how DCEP can benefit from the adaptive use of multiple placement mechanisms. We propose TCEP, a DCEP system to integrate multiple placement mechanisms. By enabling transitions, TCEP can seamlessly exchange distinct operator mechanisms at runtime. We make two main contributions that are highly important for a cost-efficient transition: i) a transition strategy for efficiently scheduling state migrations and ii) a lightweight learning algorithm to adaptively select an appropriate placement mechanism as a consequence of a transition. Our evaluations for important decentralized placement mechanisms in the context of an IoT scenario show that transitions can better fulfill QoS demands in a dynamic environment. Thereby efficient scheduling of state migrations can help to faster complete transitions by up to 94 %.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Margara:2018:Semantics" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">TSE</abbr><br />
              
          
          
      </div>
      <div class="title">On the Semantics of Distributed Reactive Programming: The Cost of Consistency</div>
      <div class="author">
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>IEEE Transactions on Software Engineering</em> 44 (7), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1109/TSE.2018.2833109" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The reactive programming paradigm aims to simplify the development of reactive systems. It provides abstractions to define time-changing values that are automatically updated by the runtime according to their dependencies. The benefits of reactive programming in distributed settings have been recognized for long. Yet, existing solutions for distributed reactive programming enforce the same semantics as in single processes, introducing communication and synchronization costs that hamper scalability. Establishing suitable abstractions for distributed reactive programming demands for a deeper investigation of the semantics of change propagation. This paper takes a foundational approach and defines precise propagation semantics in terms of consistency guarantees that constrain the order and isolation of value updates. We study the benefits and costs of these consistency guarantees both theoretically and empirically, using case studies and synthetic benchmarks. We show that different applications require different levels of consistency and that manually implementing the required level on a middleware that provides a lower one annuls the abstraction improvements of reactive programming. This motivates a framework that enables the developers to select the best trade-off between consistency and overhead for the problem at hand. To this end, we present DREAM, a distributed reactive programming middleware with flexible consistency guarantees.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Mogk:2018:Reactive" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PX</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Reactive Programming Experience with REScala</div>
      <div class="author">
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings for the 2nd International Conference on Art, Science, and Engineering of Programming</em>, ‹Programming› Companion, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3191697.3214337" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive programming is a recent programming paradigm that specifically targets reactive applications. Over the years, a number of reactive languages have been proposed, with different combinations of features, and various target domains. Unfortunately, there is a lack of knowledge about the experience of developing software applications with reactive languages. As a result, a number of design choices in reactive programming languages remain disconnected from experience and the applicability of reactive programming to various domains remains unclear. To bridge this gap, we report on our experience of developing reactive applications as well as teaching reactive programming in REScala, which we collected over several years of research and practice.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Eichholz:2018:Safe" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PASS</abbr><br />
              
          
          
      </div>
      <div class="title">Towards Safe Modular Composition of Network Functions</div>
      <div class="author">
        
          
          
          
          

          
            
              Matthias Eichholz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings for the 2nd International Conference on Art, Science, and Engineering of Programming</em>, ‹Programming› Companion, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/3191697.3213804" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Network Function Virtualization (NFV) aims to overcome the limitations of hardware middleboxes by moving network functions to software. Ultimately, this approach enables deployment into virtualized environments with higher flexibility, reducing deployment time and costs. In common industrial practice, multiple smaller network functions are often chained together into service function chains. Yet, service function chains are extremely fragile, lacking basic guarantees on correct composition and dependency reasoning. In this position paper, we propose a roadmap towards language abstractions that address this issue. We introduce the problems with current service function chaining technology and present the research program we envision.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2017</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Salvaneschi:2017:Positive" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">TSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Sebastian Proksch, 
            
          
        
          
          
          
          

          
            
              Sven Amann, 
            
          
        
          
          
          
          

          
            
              Sarah Nadi, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>IEEE Transactions on Software Engineering</em> 43 (12), 2017
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2017_On-the-Positive-Effect-of-Reactive-Programming-on-Software-Comprehension-An-Empirical-Study.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/TSE.2017.2655524" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Starting from the first investigations with strictly functional languages, reactive programming has been proposed as the programming paradigm for reactive applications. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages—including object-oriented languages—and applied reactive programming to several domains, such as GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research is that, beside other claimed advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible. This claim has never been evaluated. In this paper, we present the first empirical study that evaluates the effect of reactive programming on comprehension. The study involves&nbsp;127 subjects and compares reactive programming to the traditional object-oriented style with the Observer design pattern. Our findings show that program comprehension is significantly enhanced by the reactive-programming paradigm—a result that suggests to further develop research in this field.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Margara:2017:Consistency" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FTFJP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Consistency Types for Safe and Efficient Distributed Programming</div>
      <div class="author">
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 19th Workshop on Formal Techniques for Java-like Programs</em>, FTFJP, 2017
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2017_Consistency-Types-for-Safe-and-Efficient-Distributed-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3103111.3104044" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Consistency is a long standing problem in distributed systems. Low consistency levels are considered a necessity for scalability. High consistency is required for critical tasks such as payment and identification. Modern (geo-)distributed systems rely on the data propagation mechanisms and consistency guarantees of the distributed data store they build upon, which makes the implementation of a system that mixes different levels of consistency complex and error prone. In this paper we present preliminary work on ConSysT, a programming language that supports heterogeneous consistency specifications at the type level. In ConSysT, developers assign consistency levels directly to the data and the type system ensures the correct behavior of the application even with computations that mix data at multiple consistency levels. Our vision is that the ConSysT runtime automatically determines the most efficient mechanism to achieve the desired level of consistency among those offered by the underlying data store.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2017:QualityAware" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SEAMS</abbr><br />
              
          
          
      </div>
      <div class="title">Quality-Aware Runtime Adaptation in Complex Event Processing</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th International Symposium on Software Engineering for Adaptive and Self-Managing Systems</em>, SEAMS, 2017
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2017_Quality-aware-runtime-adaptation-in-complex-event-processing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/SEAMS.2017.10" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Complex event processing (CEP) is a fundamental paradigm for a software system to self-adapt to environmental changes. CEP provides efficient means to detect (complex) events corresponding to environmental changes by performing a real-time analysis on many, possibly heterogeneous, data sources. The way current CEP systems detect events is determined at design time without accounting for dynamic changes of the environment monitored by the CEP system. This can lead to situations where the performance, quality and reliability of event detection significantly drop (e.g., due to mobility) since initial assumptions of the environment are violated or stated too general. In this paper, we propose AdaptiveCEP, a CEP system that is able to self-adapt to detected changes in environmental conditions. We propose a CEP query language that allows specifying changes in the behavior of the CEP system and its mechanisms in detecting events dependent on environmental conditions. This way, AdaptiveCEP can select the best-suited configurations for given quality demands. In our evaluation, we show by means of a reference concept how the flexibility exposed by the query language helps to achieve significant performance gains.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2016</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Weisenburger:2016:Multitier" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SPLASH DS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multitier Reactive Abstractions</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings of the 2016 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity</em>, SPLASH Companion, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_Multitier-Reactive-Abstractions.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2984043.2984051" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed applications are traditionally developed using separate modules for each component in the distributed system, which can even be written in different programming languages. Those modules react on events such as user input, which are produced by other modules, and may in turn produce new events to be handled by different modules. Thus, most distributed applications are reactive in nature. Distributed event-based data flow makes it is hard to reason about the system and therefore makes the development of distributed systems challenging. In this paper, we present language abstractions for distributed reactive programming easing the development of such applications and supporting various distributed architectures.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Haller:2016:Reactive" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SCALA</abbr><br />
              
          
          
      </div>
      <div class="title">Reactive Async: Expressive Deterministic Concurrency</div>
      <div class="author">
        
          
          
          
          

          
            
              Philipp Haller, 
            
          
        
          
          
          
          

          
            
              Simon Geries, 
            
          
        
          
          
          
          

          
            
              Michael Eichberg, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala</em>, SCALA, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_Reactive-Async-Expressive-Deterministic-Concurrency.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2998392.2998396" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Concurrent programming is infamous for its difficulty. An important source of difficulty is non-determinism, stemming from unpredictable interleavings of concurrent activities. Futures and promises are widely-used abstractions that help designing deterministic concurrent programs, although this property cannot be guaranteed statically in mainstream programming languages. Deterministic-by-construction concurrent programming models avoid this issue, but they typically restrict expressiveness in important ways. This paper introduces a concurrent programming model, Reactive Async, which decouples concurrent computations using so-called cells, shared locations which generalize futures as well as recent deterministic abstractions such as LVars. Compared to previously proposed programming models Reactive Async provides (a) a fallback mechanism for the case where no computation ever computes the value of a given cell, and (b) explicit and optimized handling of cyclic dependencies. We present a complete implementation of the Reactive Async programming model as a library in Scala. Finally, the paper reports on a case study applying Reactive Async to static analyses of JVM bytecode based on the Opal framework.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Hauck:2016:SecureScala" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SCALA</abbr><br />
              
          
          
      </div>
      <div class="title">SecureScala: Scala Embedding of Secure Computations</div>
      <div class="author">
        
          
          
          
          

          
            
              Markus Hauck, 
            
          
        
          
          
          
          

          
            
              Savvas Savvides, 
            
          
        
          
          
          
          

          
            
              Patrick Eugster, 
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala</em>, SCALA, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_SecureScala-Scala-Embedding-of-Secure-Computations.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2998392.2998403" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Cloud computing offers an attractive and cost-efficient computing platform and hence it has been widely adopted by the industry and the government. At the same time, cloud computing poses a serious security challenge because sensitive data must often be outsourced to third party entities that can access the data and perform computations on them. Partial homomorphic encryption is promising for secure computation, since it allows programs to be executed over encrypted data. Despite advances in cryptographic techniques have improved the expressivity of such programs, integration with mainstream languages has seen little progress. To this end, we present SecureScala, a domain-specific language in Scala that allows expressing secure programs without requiring any cryptographic knowledge. SecureScala is based on a novel combination of free monads and free applicative functors and supports parallel execution and static analyzability. We evaluate our approach through several case studies, demonstrate its expressivity, and show that it incurs in limited performance overhead.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2016:Languages" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PLATEAU</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">What Do We Really Know about Data Flow Languages?</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 7th International Workshop on Evaluation and Usability of Programming Languages and Tools</em>, PLATEAU, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_What-do-we-really-know-about-data-flow-languages.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3001878.3001884" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Over the last years, a number of languages based on data flow abstractions have been proposed in different important areas including Big Data, stream processing, reactive programming, real time analytics. While there is a general agreement that the data flow style simplifies the access to such complex systems compared to low level imperative APIs, this design has been substantiated by little evidence. In this paper, we advocate a systematic investigation of the design principles of data flow languages and suggest important research questions that urge to be addressed.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Zhang:2016:Accepting" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PLDI</abbr><br />
              
          
          
      </div>
      <div class="title">Accepting Blame for Safe Tunneled Exceptions</div>
      <div class="author">
        
          
          
          
          

          
            
              Yizhou Zhang, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Quinn Beightol, 
            
          
        
          
          
          
          

          
            
              Barbara Liskov, 
            
          
        
          
          
          
          

          
            
              Andrew C. Myers
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, PLDI, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1145/2908080.2908086" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Unhandled exceptions crash programs, so a compile-time check that exceptions are handled should in principle make software more reliable. But designers of some recent languages have argued that the benefits of statically checked exceptions are not worth the costs. We introduce a new statically checked exception mechanism that addresses the problems with existing checked-exception mechanisms. In particular, it interacts well with higher-order functions and other design patterns. The key insight is that whether an exception should be treated as a "checked" exception is not a property of its type but rather of the context in which the exception propagates. Statically checked exceptions can "tunnel" through code that is oblivious to their presence, but the type system nevertheless checks that these exceptions are handled. Further, exceptions can be tunneled without being accidentally caught, by expanding the space of exception identifiers to identify the exception-handling context. The resulting mechanism is expressive and syntactically light, and can be implemented efficiently. We demonstrate the expressiveness of the mechanism using significant codebases and evaluate its performance. We have implemented this new exception mechanism as part of the new Genus programming language, but the mechanism could equally well be applied to other programming languages.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2016:Debugging" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Debugging for Reactive Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 38th International Conference on Software Engineering</em>, ICSE, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_Debugging-for-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2884781.2884815" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software. Reactive programming relieves developers from manually updating outputs when the inputs of a computation change, it overcomes a number of well-know issues of the Observer design pattern, and it makes programs more comprehensible. Unfortunately, complementing the new paradigm with proper tools is a vastly unexplored area. Hence, as of now, developers can embrace reactive programming only at the cost of a more challenging development process.</p><p>In this paper, we investigate a primary issue in the field: debugging programs in the reactive style. We analyze the problem of debugging reactive programs, show that the reactive style requires a paradigm shift in the concepts needed for debugging, and propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala IDE. Evaluation based on a controlled experiment shows that RP Debugging outperforms traditional debugging techniques.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2016:Inspector" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICSE Companion</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Debugging Reactive Programming with Reactive Inspector</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings of the 38th International Conference on Software Engineering</em>, ICSE Companion, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_Debugging-Reactive-Programming-with-Reactive-Inspector.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2889160.2893174" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive programming provides dedicated language abstractions for reactive software, relieving developers from manually updating outputs when the inputs of a computation change. Unfortunately, complementing the new paradigm with proper tools that support coding activities is a vastly unexplored area.</p><p>We investigate a primary issue in the field: debugging programs in the reactive style. We propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala development environment.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Bračevac:2016:CPL" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">MODULARITY</abbr><br />
              
          
          
      </div>
      <div class="title">CPL: A Core Language for Cloud Computing</div>
      <div class="author">
        
          
          
          
          

          
            
              Oliver Bračevac, 
            
          
        
          
          
          
          

          
            
              Sebastian Erdweg, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 15th International Conference on Modularity</em>, MODULARITY, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_CPL-A-Core-Language-for-Cloud-Computing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2889443.2889452" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Running distributed applications in the cloud involves deployment. That is, distribution and configuration of application services and middleware infrastructure. The considerable complexity of these tasks resulted in the emergence of declarative JSON-based domain-specific deployment languages to develop deployment programs. However, existing deployment programs unsafely compose artifacts written in different languages, leading to bugs that are hard to detect before run time. Furthermore, deployment languages do not provide extension points for custom implementations of existing cloud services such as application-specific load balancing policies. To address these shortcomings, we propose CPL (Cloud Platform Language), a statically-typed core language for programming both distributed applications as well as their deployment on a cloud platform. In CPL, application services and deployment programs interact through statically typed, extensible interfaces, and an application can trigger further deployment at run time. We provide a formal semantics of CPL and demonstrate that it enables type-safe, composable and extensible libraries of service combinators, such as load balancing and fault tolerance.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2015</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Zhang:2015:Lightweight" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">PLDI</abbr><br />
              
          
          
      </div>
      <div class="title">Lightweight, Flexible Object-Oriented Generics</div>
      <div class="author">
        
          
          
          
          

          
            
              Yizhou Zhang, 
            
          
        
          
          
          
          

          
            
              Matthew C. Loring, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Barbara Liskov, 
            
          
        
          
          
          
          

          
            
              Andrew C. Myers
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, PLDI, 2015
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2015_Lightweight-Flexible-Object-Oriented-Generics.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2737924.2738008" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The support for generic programming in modern object-oriented programming languages is awkward and lacks desirable expressive power. We introduce an expressive genericity mechanism that adds expressive power and strengthens static checking, while remaining lightweight and simple in common use cases. Like type classes and concepts, the mechanism allows existing types to model type constraints retroactively. For expressive power, we expose models as named constructs that can be defined and selected explicitly to witness constraints; in common uses of genericity, however, types implicitly witness constraints without additional programmer effort. Models are integrated into the object-oriented style, with features like model generics, model-dependent types, model enrichment, model multimethods, constraint entailment, model inheritance, and existential quantification further extending expressive power in an object-oriented setting. We introduce the new genericity features and show that common generic programming idioms, including current generic libraries, can be expressed more precisely and concisely. The static semantics of the mechanism and a proof of a key decidability property can be found in an associated technical report.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2015:ContextErlang" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SCP</abbr><br />
              
          
          
      </div>
      <div class="title">ContextErlang</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
        <em>Science of Computer Programming</em> 102 (C), 2015
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2015_ContextErlang-A-language-for-distributed-context-aware-self-adaptive-applications.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1016/j.scico.2014.11.016" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Self-adaptive software modifies its behavior at run time to satisfy changing requirements in a dynamic environment. Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems. COP mostly focuses on run time adaptation of the application’s behavior by supporting modular descriptions of behavioral variations. However, self-adaptive applications must satisfy additional requirements, such as distribution and concurrency, support for unforeseen changes and enforcement of correct behavior in the presence of dynamic change. Addressing these issues at the language level requires a holistic design that covers all aspects and takes into account the possibly cumbersome interaction of those features, for example concurrency and dynamic change.</p><p>We present ContextErlang, a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency. We define ContextErlang’s formal semantics, validated through an executable prototype, and we show how it supports formal proofs that the language design ensures satisfaction of certain safety requirements. We provide empirical evidence that ContextErlang is an effective solution through case studies and a performance assessment. We also show how the same design principles that lead to the development of ContextErlang can be followed to systematically design contextual extensions of other languages. A concrete example is presented concerning ContextScala.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2015:Reactive" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Reactive Programming: A Walkthrough</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          

          
            
              Giordano Tamburrelli
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 37th International Conference on Software Engineering</em>, ICSE, 2015
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2015_Reactive-Programming-A-Walkthrough.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/ICSE.2015.303" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Over the last few years, Reactive Programming has emerged as the trend to support the development of reactive software through dedicated programming abstractions. Reactive Programming has been increasingly investigated in the programming languages community and it is now gaining the interest of practitioners. Conversely, it has received so far less attention from the software engineering community.</p><p>This technical briefing bridges this gap through an accurate overview of Reactive Programming, discussing the available frameworks and outlining open research challenges with an emphasis on cross-field research opportunities.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2014</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Salvaneschi:2014:Empirical" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">An Empirical Study on Program Comprehension with Reactive Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Sven Amann, 
            
          
        
          
          
          
          

          
            
              Sebastian Proksch, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, FSE, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_An-Empirical-Study-on-Program-Comprehension-with-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2635868.2635895" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Starting from the first investigations with strictly functional languages, reactive programming has been proposed as THE programming paradigm for reactive applications. The advantages of designs based on this style over designs based on the Observer design pattern have been studied for a long time. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages – including object-oriented languages – and applied reactive programming to several domains, like GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research – that, beside other advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible – has never been evaluated. In this paper, we present the design and the results of the first empirical study that evaluates the effect of reactive programming on comprehensibility compared to the traditional object-oriented style with the Observer design pattern. Results confirm the conjecture that comprehensibility is enhanced by reactive programming. In the experiment, the reactive programming group significantly outperforms the other group.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Drechsler:2014:Distributed" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Distributed REScala: An Update Algorithm for Distributed Reactive Programming</div>
      <div class="author">
        
          
          
          
          

          
            
              Joscha Drechsler, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2014 ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications</em>, OOPSLA, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_Distributed_REScala_An_Update_Algorithm_for_Distributed_Reactive_Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2660193.2660240" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive programming improves the design of reactive applications by relocating the logic for managing dependencies between dependent values away from the application logic to the language implementation. Many distributed applications are reactive. Yet, existing change propagation algorithms are not suitable in a distributed setting.</p><p>We propose Distributed REScala, a reactive language with a change propagation algorithm that works without centralized knowledge about the topology of the dependency structure among reactive values and avoids unnecessary propagation of changes, while retaining safety guarantees (glitch freedom). Distributed REScala enables distributed reactive programming, bringing the benefits of reactive programming to distributed applications. We demonstrate the enabled design improvements by a case study. We also empirically evaluate the performance of our algorithm in comparison to other algorithms in a simulated distributed setting.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Mitschke:2014:i3QL" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
      </div>
      <div class="title">i3QL: Language-Integrated Live Data Views</div>
      <div class="author">
        
          
          
          
          

          
            
              Ralf Mitschke, 
            
          
        
          
          
          
          

          
            
              Sebastian Erdweg, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2014 ACM International Conference on Object-oriented Programming, Systems, Languages, and Applications</em>, OOPSLA, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_i3QL_Language-Integrated_Live_Data_Views.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2660193.2660242" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>An incremental computation updates its result based on a change to its input, which is often an order of magnitude faster than a recomputation from scratch. In particular, incrementalization can make expensive computations feasible for settings that require short feedback cycles, such as interactive systems, IDEs, or (soft) real-time systems.</p><p>This paper presents i3QL, a general-purpose programming language for specifying incremental computations. i3QL provides a declarative SQL-like syntax and is based on incremental versions of operators from relational algebra, enriched with support for general recursion. We integrated i3QL into Scala as a library, which enables programmers to use regular Scala code for non-incremental subcomputations of an i3QL query and to easily integrate incremental computations into larger software projects. To improve performance, i3QL optimizes user-defined queries by applying algebraic laws and partial evaluation. We describe the design and implementation of i3QL and its optimizations, demonstrate its applicability, and evaluate its performance.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2014:Programming" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">Software</abbr><br />
              
          
          
      </div>
      <div class="title">Programming with Implicit Flows</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Patrick Eugster, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        <em>IEEE Software</em> 31 (5), 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_Programming_with_Implicit_Flows.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/MS.2014.101" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Modern software differs significantly from traditional computer applications that mostly process reasonably small amounts of static input data-sets in batch mode. Modern software increasingly processes massive amounts of data, whereby it is also often the case that new input data is produced and/or existing data is modified on the fly. Consequently, programming models that facilitate the development of such software are emerging. What characterizes them is that data, respectively changes thereof, implicitly flow through computation modules. The software engineer declaratively defines computations as compositions of other computations without explicitly modeling how data should flow along dependency relations between data producer and data consumer modules, letting the runtime to automatically manage and optimize data flows.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Margara:2014:DREAM" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">We Have a DREAM: Distributed Reactive Programming with Consistency Guarantees</div>
      <div class="author">
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 8th ACM International Conference on Distributed Event-Based Systems</em>, DEBS, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_We-Have-a-DREAM-Distributed-Reactive-Programming-with-Consistency-Guarantees.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2611286.2611290" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The reactive programming paradigm has been proposed to simplify the development of reactive systems. It relies on programming primitives to express dependencies between data items and on runtime/middleware support for automated propagation of changes. Despite this paradigm is receiving increasing attention, defining the precise semantics and the consistency guarantees for reactive programming in distributed environments is an open research problem.</p><p>This paper targets such problem by studying the consistency guarantees for the propagation of changes in a distributed reactive system. In particular, it introduces three propagation semantics, namely causal, glitch free, and atomic, providing different trade-offs between costs and guarantees. Furthermore, it describes how these semantics are concretely implemented in a Distributed REActice Middleware (DREAM), which exploits a distributed event-based dispatching system to propagate changes.</p><p>We compare the performance of DREAM in a wide range of scenarios. This allows us to study the overhead introduced by the different semantics in terms of network traffic and propagation delay and to assess the efficiency of DREAM in supporting distributed reactive systems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="VanHam:2014:JEScala" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">MODULARITY</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">JEScala: Modular Coordination with Declarative Events and Joins</div>
      <div class="author">
        
          
          
          
          

          
            
              Jurgen M. Van Ham, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          

          
            
              Jacques Noyé
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 13th International Conference on Modularity</em>, MODULARITY, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_JEScala-Modular-Coordination-with-Declarative-Events-and-Joins.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2577080.2577082" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Advanced concurrency abstractions overcome the drawbacks of low-level techniques such as locks and monitors, freeing programmers that implement concurrent applications from the burden of concentrating on low-level details. However, with current approaches the coordination logic involved in complex coordination schemas is fragmented into several pieces including join patterns, data emissions triggered in different places of the application, and the application logic that implicitly creates dependencies among communication channels, hence indirectly among join patterns. We present JEScala, a language that captures coordination schemas in a more expressive and modular way by leveraging a seamless integration of an advanced event system with join abstractions. We validate our approach with case studies and provide a first performance assessment.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2014:REScala" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">MODULARITY</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">REScala: Bridging between Object-Oriented and Functional Style in Reactive Applications</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Gerold Hintz, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 13th International Conference on Modularity</em>, MODULARITY, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_REScala-Bridging-The-Gap-Between-Object-Oriented-And-Functional-Style-In-Reactive-Applications.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2577080.2577083" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Traditionally, object-oriented software adopts the Observer pattern to implement reactive behavior. Its drawbacks are well-documented and two families of alternative approaches have been proposed, extending object-oriented languages with concepts from functional reactive and dataflow programming, respectively event-driven programming. The former hardly escape the functional setting; the latter do not achieve the declarativeness of more functional approaches.</p><p>In this paper, we present REScala, a reactive language which integrates concepts from event-based and functional-reactive programming into the object-oriented world. REScala supports the development of reactive applications by fostering a functional declarative style which complements the advantages of object-oriented design.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2014:Reactive" class="col-sm-12">
    
      <div class="abbr">
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Towards Reactive Programming for Object-Oriented Applications</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Transactions on Aspect-Oriented Software Development XI</em>, Lecture Notes in Computer Science, 2014
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2014_Towards-Reactive-Programming-for-Object-Oriented-Applications.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1007/978-3-642-55099-7_7" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies – like functional reactive programming and dataflow languages – provide undoubted advantages but do not fit well with mutable objects.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2013</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Margara:2013:Ways" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">REM</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Ways to React: Comparing Reactive Languages and Complex Event</div>
      <div class="author">
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Presentation at the Workshop on Reactivity, Events and Modularity (REM)</em>, 2013
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2013_Ways-to-React-Comparing-Reactive-Languages-and-Complex-Event-Processing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive applications demand for detecting the changes that occur in a domain of interest and for timely reactions. Examples range from simple interactive applications to complex monitoring tasks involving distributed and heterogeneous systems.</p><p>Over the last years, different programming paradigms and solutions have been proposed to support such applications. In this paper, we focus on two prominent approaches: event-based programming, specifically Complex Event Processing (CEP), and Reactive Languages (RLs).</p><p>CEP systems enable the definition of high level situations of interest from low level primitive events detected in the external environment. On the other hand, RLs support time-changing values and their composition as dedicated language abstractions. These research fields have been investigated by different communities, belonging respectively to the database and the distributed systems areas and to the programming language area.</p><p>It is our belief that a deeper understanding of these research fields, including their benefits and limitations, their similarities and differences, could drive further developments in supporting reactive applications. For this reason, we propose a first comparison of the two fields. Despite huge differences, we believe that such a comparison can trigger an interesting discussion across the communities, favor knowledge sharing, and let new ideas emerge.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2013:Analysis" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">TAAS</abbr><br />
              
          
          
      </div>
      <div class="title">An Analysis of Language-Level Support for Self-Adaptive Software</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
        <em>ACM Transactions on Autonomous and Adaptive Systems</em> 8 (2), 2013
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2012_An-Analysis-of-Language-Level-Support-for-Self-Adaptive-Software.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2491465.2491466" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Self-adaptive software has become increasingly important to address the new challenges of complex computing systems. To achieve adaptation, software must be designed and implemented by following suitable criteria, methods, and strategies. Past research has been mostly addressing adaptation by developing solutions at the software architecture level. This work, instead, focuses on finer-grain programming language-level solutions. We analyze three main linguistic approaches: metaprogramming, aspect-oriented programming, and context-oriented programming. The first two are general-purpose linguistic mechanisms, whereas the third is a specific and focused approach developed to support context-aware applications. This paradigm provides specialized language-level abstractions to implement dynamic adaptation and modularize behavioral variations in adaptive systems.</p><p>The article shows how the three approaches can support the implementation of adaptive systems and compares the pros and cons offered by each solution.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2013:Distributed" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">COORDINATION</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Towards Distributed Reactive Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Joscha Drechsler, 
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the International Conference on Coordination Languages and Models</em>, COORDINATION, 2013
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2013_Towards-Distributed-Reactive-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1007/978-3-642-38493-6_16" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive applications is a wide class of software that responds to user input, network messages, and other events. Recent research on reactive languages successfully addresses the drawbacks of the Observer pattern – the traditional way reactive applications are implemented in the object-oriented setting – by introducing time-changing values and other ad-hoc programming abstractions.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2013:Reactive" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">AOSD</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/rescala">REScala <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Reactive Behavior in Object-Oriented Applications: An Analysis and a Research Roadmap</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th Annual International Conference on Aspect-Oriented Software Development</em>, AOSD, 2013
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2013_Reactive-Behavior-in-Object-oriented-Applications-An-Analysis-and-a-Research-Roadmap.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2451436.2451442" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies - like functional reactive programming and dataflow languages - provide undoubted advantages but do not fit well with mutable objects. In this paper, we provide a research roadmap to overcome the limitations of the current approaches and to support reactive applications in the OO setting. To establish a solid background for our investigation, we propose a conceptual framework to model the design space of reactive applications and we study the flaws of the existing solutions. Then we highlight how reactive languages have the potential to address those issues and we formulate our research plan.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2012</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Salvaneschi:2012:ContextOriented" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">JSS</abbr><br />
              
          
          
      </div>
      <div class="title">Context-Oriented Programming: A Software Engineering Perspective</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
        <em>Journal of Systems and Software</em> 85 (8), 2012
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2012_Context-oriented-programming-a-software-engineering-perspective.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1016/j.jss.2012.03.024" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The implementation of context-aware systems can be supported through the adoption of techniques at the architectural level such as middlewares or component-oriented architectures. It can also be supported by suitable constructs at the programming language level. Context-oriented programming (COP) is emerging as a novel paradigm for the implementation of this kind of software, in particular in the field of mobile and ubiquitous computing. The COP paradigm tackles the issue of developing context-aware systems at the language-level, introducing ad hoc language abstractions to manage adaptations modularization and their dynamic activation. In this paper we review the state of the art in the field of COP in the perspective of the benefits that this technique can provide to software engineers in the design and implementation of context-aware applications.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2012:ContextErlang" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">AOSD</abbr><br />
              
          
          
      </div>
      <div class="title">ContextErlang: Introducing Context-Oriented Programming in the Actor Model</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 11th Annual International Conference on Aspect-Oriented Software Development</em>, AOSD, 2012
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2012_ContextErlang-introducing-context-oriented-programming-in-the-actor-model.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2162049.2162072" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Self-adapting systems are becoming widespread in emerging fields such as autonomic, mobile and ubiquitous computing. Context-oriented programming (COP) is a promising language-level solution for the implementation of context-aware, self-adaptive software. However, current COP approaches struggle to effectively manage the asynchronous nature of context provisioning. We argue that, to solve these issues, COP features should be designed to fit nicely in the concurrency model supported by the language. This work presents the design rationale of ContextErlang, which introduces COP in the Actor Model. We provide evidence that ContextErlang constitutes a viable solution to implement context-aware software in a highly concurrent and distributed setting. We discuss a case study and an evaluation of run-time performance.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2011</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Maggi:2011:Finding" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICISS</abbr><br />
              
          
          
      </div>
      <div class="title">Finding Non-Trivial Malware Naming Inconsistencies</div>
      <div class="author">
        
          
          
          
          

          
            
              Federico Maggi, 
            
          
        
          
          
          
          

          
            
              Andrea Bellini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Stefano Zanero
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 7th International Conference on Information Systems Security</em>, ICISS, 2011
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2011_Finding-Non-trivial-Malware-Naming-Inconsistencies.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1007/978-3-642-25560-1_10" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Malware analysts, and in particular antivirus vendors, never agreed on a single naming convention for malware specimens. This leads to confusion and difficulty—more for researchers than for practitioners—for example, when comparing coverage of different antivirus engines, when integrating and systematizing known threats, or comparing the classifications given by different detectors. Clearly, solving naming inconsistencies is a very difficult task, as it requires that vendors agree on a unified naming convention. More importantly, solving inconsistencies is impossible without knowing exactly where they are. Therefore, in this paper we take a step back and concentrate on the problem of finding inconsistencies. To this end, we first represent each vendor’s naming convention with a graph-based model. Second, we give a precise definition of inconsistency with respect to these models. Third, we define two quantitative measures to calculate the overall degree of inconsistency between vendors. In addition, we propose a fast algorithm that finds non-trivial (i.e., beyond syntactic differences) inconsistencies. Our experiments on four major antivirus vendors and 98,798 real-world malware samples confirm anecdotal observations that different vendors name viruses differently. More importantly, we were able to find inconsistencies that cannot be inferred at all by looking solely at the syntax.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2011:JavaCtx" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">COP</abbr><br />
              
          
          
      </div>
      <div class="title">JavaCtx: Seamless Toolchain Integration for Context-Oriented Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 3rd International Workshop on Context-Oriented Programming</em>, COP, 2011
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2011_JavaCtx-Seamless-Toolchain-Integration-for-Context-Oriented-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2068736.2068740" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Context-oriented programming is an emerging paradigm addressing at the language level the issue of dynamic software adaptation and modularization of context-specific concerns. In this paper we propose JavaCtx, a tool which employs coding conventions to generate the context-aware semantics for Java programs and subsequently weave it into the application. The contribution of JavaCtx is twofold: the design of a set of coding conventions which allow to write context-oriented software in plain Java and the concept of context-oriented semantics injection, which allows to introduce the context-aware semantics through standard aspect-oriented programming. Both of these points allow to seamless integrate JavaCtx in the existing industrial-strength appliances and so ease the development of context-oriented software in consolidated industrial settings.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Ghezzi:2011:Evaluation" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SEAMS</abbr><br />
              
          
          
      </div>
      <div class="title">An Evaluation of the Adaptation Capabilities in Programming Languages</div>
      <div class="author">
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems</em>, SEAMS, 2011
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2011_An-Evaluation-of-the-Adaptation-Capabilities-in-Programming-Languages.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/1988008.1988016" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>In recent years the need for software applications to adapt to the environment in which they are situated has become common. Beside architectural approaches, language-level support for the development of adaptable and context-aware software have been investigated. Many existing solutions adopt ad hoc programming paradigms such as aspect oriented programming (AOP) or context oriented programming (COP). In this paper we investigate the use of the abstractions offered by traditional object-oriented and functional paradigms for the development of context-adaptable systems. We carry out our analysis along a set of conceptual directions which consider the requirement of functional adaptation beside non functional requirements such as safety and effective modularization. Our analysis were validated though the development of several prototypes of an adaptable cache server which is chosen as the running example through the paper. We provide an estimation of the performance advantages of the techniques based traditional programming languages compared with context-oriented programming.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2011:ContextOriented" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">CoRR</abbr><br />
              
          
          
      </div>
      <div class="title">Context-Oriented Programming: A Programming Paradigm for Autonomic Systems</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella
            
          
        
      </div>

      <div class="periodical">
      
          arXiv, 2011
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://arxiv.org/abs/1105.0069" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Dynamic software adaptability is one of the central features leveraged by autonomic computing. However, developing software that changes its behavior at run time adapting to the operational conditions is a challenging task. Several approaches have been proposed in the literature to attack this problem at different and complementary abstraction levels: software architecture, middleware, and programming level. We focus on the support that ad-hoc programming language constructs may provide to support dynamically adaptive behaviors. We introduce context-oriented programming languages and we present a framework that positions the supported paradigm in the MAPE-K autonomic loop. We discuss the advantages of using context-oriented programming languages instead of other mainstream approaches based on dynamic aspect-oriented programming languages. We present a preliminary case study that shows how the proposed programming style naturally fits dynamic adaptation requirements and we extensively evaluate the use of COP in this scenario. Finally, we discuss some known problems and outline a number of open research challenges.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Salvaneschi:2011:Metrics" class="col-sm-12">
    
      <div class="abbr">
          
          
      </div>
      <div class="title">Metrics of Software Security</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          
            
              
            
          

          
            
              Paolo Salvaneschi
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Encyclopedia of Cryptography and Security, 2nd Ed</em>, 2011
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1007/978-1-4419-5906-5_680" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Measuring software security requires to identify measurable properties of a software artifact and to build models that can relate the measures to a qualitative or quantitative value of the property “security”.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2010</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Ghezzi:2010:Context" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">COP</abbr><br />
              
          
          
      </div>
      <div class="title">Context Oriented Programming in Highly Concurrent Systems</div>
      <div class="author">
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2nd International Workshop on Context-Oriented Programming</em>, COP, 2010
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2010_Context-Oriented-Programming-in-Highly-Concurrent-Systems.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/1930021.1930022" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Context Oriented Programming (COP) allows modularization of programs according to the cross-cutting concern of contexts. Context depending features are grouped in layers which can be activated at run time by triggering the associated behavioral variations.</p><p>COP extensions have been provided for different languages. However all of them enforce a thread, shared-memory based concurrency model. In this paper we discuss how the COP paradigm can be applied to message-based concurrent systems which support the agents paradigm. The discussion is supported by the case of ContextErlang, our COP-inspired contextual version of Erlang.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Comparetti:2010:Identifying" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SP</abbr><br />
              
          
          
      </div>
      <div class="title">Identifying Dormant Functionality in Malware Programs</div>
      <div class="author">
        
          
          
          
          

          
            
              Paolo Milani Comparetti, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Engin Kirda, 
            
          
        
          
          
          
          

          
            
              Clemens Kolbitsch, 
            
          
        
          
          
          
          

          
            
              Christopher Kruegel, 
            
          
        
          
          
          
          

          
            
              Stefano Zanero
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2010 IEEE Symposium on Security and Privacy</em>, SP, 2010
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2010_Identifying-Dormant-Functionality-in-Malware-Programs.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/SP.2010.12" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>To handle the growing flood of malware, security vendors and analysts rely on tools that automatically identify and analyze malicious code. Current systems for automated malware analysis typically follow a dynamic approach, executing an unknown program in a controlled environment (sandbox) and recording its runtime behavior. Since dynamic analysis platforms directly run malicious code, they are resilient to popular malware defense techniques such as packing and code obfuscation. Unfortunately, in many cases, only a small subset of all possible malicious behaviors is observed within the short time frame that a malware sample is executed. To mitigate this issue, previous work introduced techniques such as multi-path or forced execution to increase the coverage of dynamic malware analysis. Unfortunately, using these techniques is potentially expensive, as the number of paths that require analysis can grow exponentially. In this paper, we propose Reanimator, a novel solution to determine the capabilities (malicious functionality) of malware programs. Our solution is based on the insight that we can leverage behavior observed while dynamically executing a specific malware sample to identify similar functionality in other programs. More precisely, when we observe malicious actions during dynamic analysis, we automatically extract and model the parts of the malware binary that are responsible for this behavior. We then leverage these models to check whether similar code is present in other samples. This allows us to statically identify dormant functionality (functionality that is not observed during dynamic analysis) in malicious programs. We evaluate our approach on thousands of real-world malware samples, and we show that our system is successful in identifying additional, malicious functionality. As a result, our approach can significantly improve the coverage of malware analysis results.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Ghezzi:2010:Programming" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SEAMS</abbr><br />
              
          
          
      </div>
      <div class="title">Programming Language Support to Context-Aware Adaptation: A Case-Study with Erlang</div>
      <div class="author">
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Matteo Pradella, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2010 ICSE Workshop on Software Engineering for Adaptive and Self-Managing Systems</em>, SEAMS, 2010
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2010_Programming-Language-Support-to-Context-Aware-Adaptation-A-Case-Study-with-Erlang.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/1808984.1808991" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Software applications are increasingly situated in a world where context changes continuously. At the same time, applications need to provide continuous service, and the service provided often needs to change in order to adapt to the new contexts. Context-aware adaptation can be greatly facilitated by using programming languages that natively support high-level features to deal with contexts, context changes, and context-aware behaviors. Although context-oriented programming has been around for a while, most existing efforts focus on incorporating context-oriented features in languages that are not primarily oriented to concurrency, distribution, and dynamic reconfiguration. These features, however, characterize most pervasive context-aware situations. In this work, we illustrate how context-aware programming primitives may introduced in the parallel and distributed Erlang programming language. We also present an extended example, which illustrates the benefits of using our extension (ContextErlang) to design context-aware pervasive applications.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Ghezzi:2010:Automatic" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FASE</abbr><br />
              
          
          
      </div>
      <div class="title">Automatic Cross Validation of Multiple Specifications: A Case Study</div>
      <div class="author">
        
          
          
          
          

          
            
              Carlo Ghezzi, 
            
          
        
          
          
          
          

          
            
              Andrea Mocci, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 13th International Conference on Fundamental Approaches to Software Engineering</em>, FASE, 2010
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.1007/978-3-642-12029-9_17" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>The problem of formal software specification has been addressed and discussed since the infancy of software engineering. However, among all the proposed solutions, none is universally accepted yet. Many different formal descriptions can in fact be given for the same software component; thus, the problem of determining the consistency relation among those descriptions becomes relevant and potentially critical. In this work, we propose a method for comparing two specific kinds of formal specifications of containers. In particular, we check the consistency of intensional behavior models with algebraic specifications. The consistency check is performed by generating a behavioral equivalence model from the intensional model, converting the algebraic axioms into temporal logic formulae, and then checking them against the model by using the NuSMV model checker. An automated software tool which encodes the problem as model checking has been implemented to check the consistency of recovered specifications of relevant Java classes.</p>
    </div>
    
  </div>
</div>
</li></ol>

  <h2 class="year">2009</h2>
  <ol class="bibliography"><li><div class="row">


  <div id="Criscione:2009:Integrated" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">EC2ND</abbr><br />
              
          
          
      </div>
      <div class="title">Integrated Detection of Attacks Against Browsers, Web Applications and Databases</div>
      <div class="author">
        
          
          
          
          

          
            
              Claudio Criscione, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Federico Maggi, 
            
          
        
          
          
          
          

          
            
              Stefano Zanero
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2009 European Conference on Computer Network Defense</em>, EC2ND, 2009
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2009_Integrated-Detection-of-Attacks-Against-Browsers-Web-Applications-and-Databases.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/EC2ND.2009.13" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Anomaly-based techniques were exploited successfully to implement protection mechanisms for various systems. Recently, these approaches have been ported to the web domain under the name of "web application anomaly detectors" (or firewalls) with promising results. In particular, those capable of automatically building specifications, or models, of the protected application by observing its traffic (e.g., network packets, system calls, or HTTP requests and responses) are particularly interesting, since they can be deployed with little effort.</p><p>Typically, the detection accuracy of these systems is significantly influenced by the model building phase (often called training), which clearly depends upon the quality of the observed traffic, which should resemble the normal activity of the protected application and must be also free from attacks. Otherwise, detection may result in significant amounts of false positives (i.e., benign events flagged as anomalous) and negatives (i.e., undetected threats).</p><p>In this work we describe Masibty, a web application anomaly detector that have some interesting properties. First, it requires the training data not to be attack-free. Secondly, not only it protects the monitored application, it also detects and blocks malicious client-side threats before they are sent to the browser. Third, Masibty intercepts the queries before they are sent to the database, correlates them with the corresponding HTTP requests and blocks those deemed anomalous.</p><p>Both the accuracy and the performance have been evaluated on real-world web applications with interesting results. The system is almost not influenced by the presence of attacks in the training data and shows only a negligible amount of false positives, although this is paid in terms of a slight performance overhead.</p>
    </div>
    
  </div>
</div>
</li></ol>


</div>


      
  </article>

</div>

    </div>

    <!-- Footer -->

    
<footer class="sticky-bottom mt-5">
  <div class="container">
    &copy; Copyright 2022   Programming Group.
    
    
    <a href="https://programming-group.com/impressum">Impressum</a>.
    
    
    Last updated: August 31, 2022.
    
  </div>
</footer>



    <script type="text/javascript" src="/assets/css/bundle-f83a6549c9380ccdc3ff0fc271d913db.js"></script>
  </body>
</html>
